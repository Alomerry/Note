<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Clean Code | Alomerry Note</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.107edffb.css" as="style"><link rel="preload" href="/assets/js/app.e9492735.js" as="script"><link rel="preload" href="/assets/js/2.6b359cc1.js" as="script"><link rel="preload" href="/assets/js/11.d727faee.js" as="script"><link rel="prefetch" href="/assets/js/10.9aac6882.js"><link rel="prefetch" href="/assets/js/12.3454b72b.js"><link rel="prefetch" href="/assets/js/13.5e522739.js"><link rel="prefetch" href="/assets/js/14.1978c3ed.js"><link rel="prefetch" href="/assets/js/15.70d859ea.js"><link rel="prefetch" href="/assets/js/16.35f1ad07.js"><link rel="prefetch" href="/assets/js/17.d2118fe4.js"><link rel="prefetch" href="/assets/js/18.9bbddd90.js"><link rel="prefetch" href="/assets/js/19.429eaf50.js"><link rel="prefetch" href="/assets/js/20.04f4e752.js"><link rel="prefetch" href="/assets/js/21.3df04893.js"><link rel="prefetch" href="/assets/js/22.61606323.js"><link rel="prefetch" href="/assets/js/23.8c2ce7d5.js"><link rel="prefetch" href="/assets/js/24.e2c8ca62.js"><link rel="prefetch" href="/assets/js/25.891f4aa4.js"><link rel="prefetch" href="/assets/js/26.dc607d5d.js"><link rel="prefetch" href="/assets/js/27.92461dfb.js"><link rel="prefetch" href="/assets/js/3.92631181.js"><link rel="prefetch" href="/assets/js/4.4cedf91f.js"><link rel="prefetch" href="/assets/js/5.2b16318d.js"><link rel="prefetch" href="/assets/js/6.52b733f1.js"><link rel="prefetch" href="/assets/js/7.f8532b93.js"><link rel="prefetch" href="/assets/js/8.7034377b.js"><link rel="prefetch" href="/assets/js/9.1cd35f27.js">
    <link rel="stylesheet" href="/assets/css/0.styles.107edffb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Alomerry Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="http://alomerry.com" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="http://alomerry.com" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>书籍笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/books/cleanCode.html" aria-current="page" class="active sidebar-link">Clean Code</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_2-有意义的命名" class="sidebar-link">2 有意义的命名</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_2-2-名副其实" class="sidebar-link">2.2 名副其实</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_2-3-避免误导" class="sidebar-link">2.3 避免误导</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_2-6-使用搜索的名称" class="sidebar-link">2.6 使用搜索的名称</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_2-9-类名" class="sidebar-link">2.9 类名</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_2-10-方法名" class="sidebar-link">2.10 方法名</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_2-16-添加有意义的语境" class="sidebar-link">2.16 添加有意义的语境</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-函数" class="sidebar-link">3 函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-2-只做一件事" class="sidebar-link">3.2 只做一件事</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-3-每个函数一个抽象层级" class="sidebar-link">3.3 每个函数一个抽象层级</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-4-switch-语句" class="sidebar-link">3.4 switch 语句</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-6-函数参数" class="sidebar-link">3.6 函数参数</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-7-无副作用" class="sidebar-link">3.7 无副作用</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-8-分隔指令和询问" class="sidebar-link">3.8 分隔指令和询问</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_3-9-使用异常代替返回错误码" class="sidebar-link">3.9 使用异常代替返回错误码</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_6-对象和数据结构" class="sidebar-link">6 对象和数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_6-2-数据、对象的反对称性" class="sidebar-link">6.2 数据、对象的反对称性</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_7-处理异常" class="sidebar-link">7 处理异常</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_7-3-使用不可控异常" class="sidebar-link">7.3 使用不可控异常</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_7-6-定义常规流程" class="sidebar-link">7.6 定义常规流程</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_7-7-不要返回-null-值" class="sidebar-link">7.7 不要返回 null 值</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_7-8-不要传递-null-值" class="sidebar-link">7.8 不要传递 null 值</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_7-9-小结" class="sidebar-link">7.9 小结</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_10-类" class="sidebar-link">10 类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_10-2-类应该短小" class="sidebar-link">10.2 类应该短小</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_11-系统" class="sidebar-link">11 系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_11-2-将系统的构造与使用分开" class="sidebar-link">11.2 将系统的构造与使用分开</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_11-3-扩容" class="sidebar-link">11.3 扩容</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_11-5-纯-java-aop-框架" class="sidebar-link">11.5 纯 Java AOP 框架</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_11-6-aspectj-的方面" class="sidebar-link">11.6 AspectJ 的方面</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_12-迭进" class="sidebar-link">12 迭进</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_12-4-不可重复" class="sidebar-link">12.4 不可重复</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_12-5-表达力" class="sidebar-link">12.5 表达力</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_12-6-尽可能少的类和方法" class="sidebar-link">12.6 尽可能少的类和方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_13-并发编程" class="sidebar-link">13 并发编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_13-1-为何要并发" class="sidebar-link">13.1 为何要并发</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_13-5-执行模型" class="sidebar-link">13.5 执行模型</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_13-7-保持同步区域微小" class="sidebar-link">13.7 保持同步区域微小</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_13-9-测试多线程" class="sidebar-link">13.9 测试多线程</a></li></ul></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_17" class="sidebar-link">17</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_17-4-一般性问题" class="sidebar-link">17.4 一般性问题</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_17-5-java" class="sidebar-link">17.5 Java</a></li><li class="sidebar-sub-header"><a href="/books/cleanCode.html#_17-6-名称" class="sidebar-link">17.6 名称</a></li></ul></li></ul></li><li><a href="/books/csapp.html" class="sidebar-link">CSAPP</a></li><li><a href="/books/gopl.html" class="sidebar-link">The Go Programming Language</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法解析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其它笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>语言心得</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>文档工具</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="clean-code"><a href="#clean-code" class="header-anchor">#</a> Clean Code</h1> <h2 id="_2-有意义的命名"><a href="#_2-有意义的命名" class="header-anchor">#</a> 2 有意义的命名</h2> <h3 id="_2-2-名副其实"><a href="#_2-2-名副其实" class="header-anchor">#</a> 2.2 名副其实</h3> <h3 id="_2-3-避免误导"><a href="#_2-3-避免误导" class="header-anchor">#</a> 2.3 避免误导</h3> <p>代码需要简洁，但是不能模糊。</p> <p>例如下面两个变量名：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>XYZControllerForEfficientKeepingOfStrings

XYZControllerForEfficientHoldingOfStrings
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在区分两个变量的意思时需要反复对比，是很痛苦的。避免细微之处有不同</p> <h3 id="_2-6-使用搜索的名称"><a href="#_2-6-使用搜索的名称" class="header-anchor">#</a> 2.6 使用搜索的名称</h3> <h3 id="_2-9-类名"><a href="#_2-9-类名" class="header-anchor">#</a> 2.9 类名</h3> <p>类名和对象名应该是名词或名词短语，不应当是动词。</p> <h3 id="_2-10-方法名"><a href="#_2-10-方法名" class="header-anchor">#</a> 2.10 方法名</h3> <p>方法名应该是动词或动词短语。属性访问器、修改器和断言应该根据其值命名。</p> <h3 id="_2-16-添加有意义的语境"><a href="#_2-16-添加有意义的语境" class="header-anchor">#</a> 2.16 添加有意义的语境</h3> <h2 id="_3-函数"><a href="#_3-函数" class="header-anchor">#</a> 3 函数</h2> <h3 id="_3-2-只做一件事"><a href="#_3-2-只做一件事" class="header-anchor">#</a> 3.2 只做一件事</h3> <p>函数应该做一件事。做好这件事。只做这一件事。</p> <h3 id="_3-3-每个函数一个抽象层级"><a href="#_3-3-每个函数一个抽象层级" class="header-anchor">#</a> 3.3 每个函数一个抽象层级</h3> <h3 id="_3-4-switch-语句"><a href="#_3-4-switch-语句" class="header-anchor">#</a> 3.4 switch 语句</h3> <p>单一权责原则</p> <p>开放闭合原则</p> <h3 id="_3-6-函数参数"><a href="#_3-6-函数参数" class="header-anchor">#</a> 3.6 函数参数</h3> <p>减少参数数量</p> <h4 id="_3-6-2-标识参数"><a href="#_3-6-2-标识参数" class="header-anchor">#</a> 3.6.2 标识参数</h4> <p>避免使用标识参数，如 <code>bool</code> 型参数，一旦使用，就表明方法中会因为 true 和 false 做不同的事</p> <h4 id="_3-6-7-动词和关键词"><a href="#_3-6-7-动词和关键词" class="header-anchor">#</a> 3.6.7 动词和关键词</h4> <p>一元函数应当形成一种良好的动词/名词对形式，例如： <code>write(name)</code>、<code>writeField(name)</code>。</p> <p>函数名称展示关键字形式可以减轻记忆参数顺序的负担，例如：<code>assertEqual(expected,actual)</code> 修改成 <code>assertExpectedEqualsActual(expected,actual)</code>。</p> <h3 id="_3-7-无副作用"><a href="#_3-7-无副作用" class="header-anchor">#</a> 3.7 无副作用</h3> <p>避免做函数承诺的以外的事情。</p> <h3 id="_3-8-分隔指令和询问"><a href="#_3-8-分隔指令和询问" class="header-anchor">#</a> 3.8 分隔指令和询问</h3> <p>函数应该修改某对象的状态，或是返回某对象的相关信息，但两者不可兼得。例如：</p> <p><code>if (set(&quot;usename&quot;,&quot;unclebob&quot;))...</code></p> <h3 id="_3-9-使用异常代替返回错误码"><a href="#_3-9-使用异常代替返回错误码" class="header-anchor">#</a> 3.9 使用异常代替返回错误码</h3> <h4 id="_3-9-1-抽离-try-catch代码块"><a href="#_3-9-1-抽离-try-catch代码块" class="header-anchor">#</a> 3.9.1 抽离 Try/Catch代码块</h4> <h4 id="_3-9-3-error-java-依赖磁铁"><a href="#_3-9-3-error-java-依赖磁铁" class="header-anchor">#</a> 3.9.3 Error.java 依赖磁铁</h4> <p>返回错误码通常暗示某处有个类或是枚举，定义了所有错误码。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Error</span> <span class="token punctuation">{</span>
  OK<span class="token punctuation">,</span>
  INVALID<span class="token punctuation">,</span>
  NO_SUCH<span class="token punctuation">,</span>
  LOCKED<span class="token punctuation">,</span>
  OUT_OF_RESOURCES<span class="token punctuation">,</span>
  WAITING_FOR_EVENT<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这样的类就是一块<strong>依赖磁铁（dependency magnet）</strong>。其它类都导入和使用它。当 Error 枚举修改时，所有这些其它的类需要重新编译和部署。</p> <p>使用异常代替错误码，新异常就可以从异常类派生出来。</p> <h2 id="_6-对象和数据结构"><a href="#_6-对象和数据结构" class="header-anchor">#</a> 6 对象和数据结构</h2> <h3 id="_6-2-数据、对象的反对称性"><a href="#_6-2-数据、对象的反对称性" class="header-anchor">#</a> 6.2 数据、对象的反对称性</h3> <p>过程式代码（使用数据结构的代码）便于在不改动既有的数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。</p> <p>过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有子类。</p> <h2 id="_7-处理异常"><a href="#_7-处理异常" class="header-anchor">#</a> 7 处理异常</h2> <h3 id="_7-3-使用不可控异常"><a href="#_7-3-使用不可控异常" class="header-anchor">#</a> 7.3 使用不可控异常</h3> <p>可控异常的代价是违反开放封闭原则。如果在方法中抛出可控异常，就得在 catch 语句中和抛出异常处之间的每个方法签名中声明该异常。即意味着对软件较低层次的修改，都将波及较高层级的签名。</p> <h3 id="_7-6-定义常规流程"><a href="#_7-6-定义常规流程" class="header-anchor">#</a> 7.6 定义常规流程</h3> <p>可以使用<strong>特例模式</strong>。创建类或者配置对象处理特例，这样客户端就不用应付异常了。</p> <h3 id="_7-7-不要返回-null-值"><a href="#_7-7-不要返回-null-值" class="header-anchor">#</a> 7.7 不要返回 null 值</h3> <p>给调用者添加麻烦，只要有一处没有检查 null 值，程序就会失控。</p> <h3 id="_7-8-不要传递-null-值"><a href="#_7-8-不要传递-null-值" class="header-anchor">#</a> 7.8 不要传递 null 值</h3> <h3 id="_7-9-小结"><a href="#_7-9-小结" class="header-anchor">#</a> 7.9 小结</h3> <p>将错误处理隔离看待，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步就能单独处理错误，提高了代码的可维护性。</p> <h2 id="_10-类"><a href="#_10-类" class="header-anchor">#</a> 10 类</h2> <h3 id="_10-2-类应该短小"><a href="#_10-2-类应该短小" class="header-anchor">#</a> 10.2 类应该短小</h3> <h4 id="_10-2-1-单一权责原则"><a href="#_10-2-1-单一权责原则" class="header-anchor">#</a> 10.2.1 单一权责原则</h4> <p>类或模块应有且只有一个修改理由。</p> <p>系统应该由许多短小的类而不是少量巨大的类。有大量短小类的系统并不比有少量庞大类的系统拥有更多移动部件。每个达到一定规模的系统都会包含大量逻辑和复杂性。管理这种复杂性的首要目标就是加以组织。</p> <h4 id="_10-2-2-内聚"><a href="#_10-2-2-内聚" class="header-anchor">#</a> 10.2.2 内聚</h4> <p>保持函数和参数列表短小，有时会导致一组子集方法所用的实体变量数增加，这时尝试将变量和方法拆分到多个类中，让新的类更为内聚。</p> <h2 id="_11-系统"><a href="#_11-系统" class="header-anchor">#</a> 11 系统</h2> <h3 id="_11-2-将系统的构造与使用分开"><a href="#_11-2-将系统的构造与使用分开" class="header-anchor">#</a> 11.2 将系统的构造与使用分开</h3> <blockquote><p>软件系统应将起始启始过程和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在互相缠结的依赖关系。</p></blockquote> <p>多数程序没有做分离处理，启始过程代码很特殊，被混杂到运行时逻辑中。如下例：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Service</span> <span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>service <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Good enought default for most case?</span>
  <span class="token keyword">return</span> service<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这就是所谓 <strong>延时初始化/赋值</strong>，也有一些好处。在真正用到对象前，无需操心这种架空构造，启始时间也会更短，还能保证永远不返回 null 值。</p> <p>然而这样同时也得到了 MyServiceImp 及其构造器所需一切的硬编码依赖。不分解这些依赖关系就无法编译，即便是在运行时永远不使用这种类型的对象。</p> <p>如果 MyServiceImpl 是个重型对象，则测试也会是个问题。首先必须要保证在单元测试调用方法之前，就给 Service 指派恰当的测试替身（TEST DOUBLE）或仿制对象（MOCK OBJECT）。由于构造逻辑与运行过程相混杂，我们必须测试所有的执行路径（例如， null 值测试及其代码块）。有了这些权责，说明方法做了不止一件事，这样就略微违反了<strong>单一权责原则</strong>。</p> <p>最糟糕的是不知道 MyServiceImpl 在所有的情形中是否都是正确的对象。为什么该方法的所属类必须要知道全局情景？我们是否正能知道在这里要用到的正确对象？是否真有可能存在一种放之四海而皆准的类型？</p> <p>如果应用程序中有许多类似的情况，四散分布，缺乏模块组织性，就会有许多重复代码。</p> <p>如果勤于打造有着良好格式并且强固的系统，就不应该让这类就手小技巧破坏模块组织性。对象构造的启始和设置过程也不例外。</p> <h4 id="_11-2-2-工厂"><a href="#_11-2-2-工厂" class="header-anchor">#</a> 11.2.2 工厂</h4> <h4 id="_11-2-3-依赖注入"><a href="#_11-2-3-依赖注入" class="header-anchor">#</a> 11.2.3 依赖注入</h4> <h3 id="_11-3-扩容"><a href="#_11-3-扩容" class="header-anchor">#</a> 11.3 扩容</h3> <p>“一开始就做对系统”纯属神话。反之只应该去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发、重构以及它们打造出的整洁代码，在代码层面保证了这个过程的实现。</p> <blockquote><p>软件系统与物理系统可以类比。它们的架构都可以递增式地增长，只要我们持续将关注面恰当的切分。</p></blockquote> <h3 id="_11-5-纯-java-aop-框架"><a href="#_11-5-纯-java-aop-框架" class="header-anchor">#</a> 11.5 纯 Java AOP 框架</h3> <h3 id="_11-6-aspectj-的方面"><a href="#_11-6-aspectj-的方面" class="header-anchor">#</a> 11.6 AspectJ 的方面</h3> <h2 id="_12-迭进"><a href="#_12-迭进" class="header-anchor">#</a> 12 迭进</h2> <h3 id="_12-4-不可重复"><a href="#_12-4-不可重复" class="header-anchor">#</a> 12.4 不可重复</h3> <p>小规模复用 =&gt; 大规模复用</p> <h3 id="_12-5-表达力"><a href="#_12-5-表达力" class="header-anchor">#</a> 12.5 表达力</h3> <blockquote><p>我们中的大多数人都经理过费解代码的纠缠。我们中的许多人自己就编写过费解的代码。写出自己能理解的代码很容易，因为在写这些代码时，我们正深入于要解决的问题中。代码的其它维护者不会那么深入，也就不易理解代码。</p> <p>软件项目的主要成本在于长期维护。为了在修改时尽量降低出现缺陷的可能性，很有必要理解系统是做什么的。当系统变得越来越复杂，开发者就需要越来越多的时间来理解它，而且极有可能误解。所以，代码应当清晰地表达其作者的意图。作者把代码写的越清晰，其他人花在理解代码上的时间就越少，从而减少缺陷，缩减维护成本。</p> <p>不过，做到有表达力的最重要方式却是 <strong>尝试</strong>。有太多时间，我们写出能工作的代码，就转移到下一个问题上，没有下足功夫调整代码，让后来者易于阅读。记住，下一位读代码的人最有可能是你自己。</p> <p>所以，多少尊重一下你的手艺吧。花一点时间在每个函数和类上。选用较好的名称，将大函数切分成小函数。时时照拂自己创建的东西。用心是最珍贵的资源。</p></blockquote> <h3 id="_12-6-尽可能少的类和方法"><a href="#_12-6-尽可能少的类和方法" class="header-anchor">#</a> 12.6 尽可能少的类和方法</h3> <p>避免过度使用消除重复、代码表达力和 SRP 等基础的概念。目标是保持函数和类短小的同时，保持整个系统短小精悍。</p> <h2 id="_13-并发编程"><a href="#_13-并发编程" class="header-anchor">#</a> 13 并发编程</h2> <h3 id="_13-1-为何要并发"><a href="#_13-1-为何要并发" class="header-anchor">#</a> 13.1 为何要并发</h3> <ul><li><p>并发总能改进性能。并发有时能改进性能，但只在多个线程或多处理器之间能分享大量等待时间的时候管用。事情没那么简单。</p></li> <li><p>编写并发程序无需修改设计。事实上，并发算法的设计有可能与单线程系统的设计极不相同。目的与时机的解耦往往对系统结构产生巨大的影响。</p></li> <li><p>并发会在性能和编写额外代码上增加一些开销；</p></li> <li><p>正确的并发是复杂的，即使对于简单的问题也是如此；</p></li> <li><p>并发的缺陷并非总能重现，所以常被看作偶发事件而忽略，未被当做真的缺陷看待；</p></li> <li><p>并发常常需要对设计策略做根本性修改。</p></li></ul> <h3 id="_13-5-执行模型"><a href="#_13-5-执行模型" class="header-anchor">#</a> 13.5 执行模型</h3> <h4 id="_13-5-1-生产者-消费者模型"><a href="#_13-5-1-生产者-消费者模型" class="header-anchor">#</a> 13.5.1 生产者-消费者模型</h4> <h4 id="_13-5-2-读者-作者模型"><a href="#_13-5-2-读者-作者模型" class="header-anchor">#</a> 13.5.2 读者-作者模型</h4> <h4 id="_13-5-3-哲学家就餐模型"><a href="#_13-5-3-哲学家就餐模型" class="header-anchor">#</a> 13.5.3 哲学家就餐模型</h4> <h3 id="_13-7-保持同步区域微小"><a href="#_13-7-保持同步区域微小" class="header-anchor">#</a> 13.7 保持同步区域微小</h3> <p>关键字 <code>synchoronized</code> 制造了锁。同一个锁维护的所有区域在任一时刻保证只有一个线程执行。锁是昂贵的，因为它们带来了延迟和额外的开销。所以不应将代码扔给 <code>synchronized</code> 语句了事。临界区应该被保护起来，所以应该尽可能少地设计临界区。</p> <p>将同步延展到最小临界区范围之外会增加资源争用、降低执行效率。</p> <h3 id="_13-9-测试多线程"><a href="#_13-9-测试多线程" class="header-anchor">#</a> 13.9 测试多线程</h3> <h4 id="_13-9-3-编写可拔插的线程代码"><a href="#_13-9-3-编写可拔插的线程代码" class="header-anchor">#</a> 13.9.3 编写可拔插的线程代码</h4> <h4 id="_13-9-4-编写可调整的线程代码"><a href="#_13-9-4-编写可调整的线程代码" class="header-anchor">#</a> 13.9.4 编写可调整的线程代码</h4> <h2 id="_17"><a href="#_17" class="header-anchor">#</a> 17</h2> <h3 id="_17-4-一般性问题"><a href="#_17-4-一般性问题" class="header-anchor">#</a> 17.4 一般性问题</h3> <h4 id="g5-重复"><a href="#g5-重复" class="header-anchor">#</a> G5 重复</h4> <p>DRY 原则（Don't Repeat Yourself）</p> <h4 id="g10-垂直分隔"><a href="#g10-垂直分隔" class="header-anchor">#</a> G10 垂直分隔</h4> <p>变量和函数应该在靠近被使用的地方定义。</p> <h4 id="g13-人为耦合"><a href="#g13-人为耦合" class="header-anchor">#</a> G13 人为耦合</h4> <h4 id="g15-算子参数"><a href="#g15-算子参数" class="header-anchor">#</a> G15 算子参数</h4> <h4 id="g23-用多态代替-if-else-或-switch-case"><a href="#g23-用多态代替-if-else-或-switch-case" class="header-anchor">#</a> G23 用多态代替 if/else 或 switch/case</h4> <h4 id="g28-封装条件"><a href="#g28-封装条件" class="header-anchor">#</a> G28 封装条件</h4> <p>如果没有 if 或 while 语句的上下文，布尔逻辑就难以理解。</p> <p>例如：</p> <p><code>if (shouldBeDeleted(timer))</code></p> <p>要好于</p> <p><code>if (timer.hasExpired()) &amp;&amp; !timer.isRecurrent())</code></p> <h4 id="g29-避免否定性条件"><a href="#g29-避免否定性条件" class="header-anchor">#</a> G29 避免否定性条件</h4> <p>否定式肯定比肯定式难明白一些，所以尽可能用肯定形式。例如：</p> <p><code>if (buffer.shouldCompact())</code></p> <p>要好于</p> <p><code>if (!buffer.shouldNotCompact())</code></p> <h4 id="g33-封装边界条件"><a href="#g33-封装边界条件" class="header-anchor">#</a> G33 封装边界条件</h4> <h4 id="g35-在较高层级放置可配置数据"><a href="#g35-在较高层级放置可配置数据" class="header-anchor">#</a> G35 在较高层级放置可配置数据</h4> <h4 id="g36-避免传递浏览"><a href="#g36-避免传递浏览" class="header-anchor">#</a> G36 避免传递浏览</h4> <h3 id="_17-5-java"><a href="#_17-5-java" class="header-anchor">#</a> 17.5 Java</h3> <h4 id="j2-不要继承常量"><a href="#j2-不要继承常量" class="header-anchor">#</a> J2 不要继承常量</h4> <h3 id="_17-6-名称"><a href="#_17-6-名称" class="header-anchor">#</a> 17.6 名称</h3> <h4 id="n1-采用描述性名称"><a href="#n1-采用描述性名称" class="header-anchor">#</a> N1：采用描述性名称</h4> <blockquote><p>不要太快取名。确认名称具有描述性。记住，事物的意义随着软件的演化而变化，所以，要经常性地重新估量名称是否恰当。</p> <p>仔细取好的名字的威力在于，它用描述性信息覆盖了代码。这种信息覆盖设定了读者对于模块其它函数行为的期待。通过阅读代码你就能推断出方法的实现。读完方法时，你会感到它“深和你意”。</p></blockquote> <h4 id="n5-为较大作用范围选用较长名称"><a href="#n5-为较大作用范围选用较长名称" class="header-anchor">#</a> N5 为较大作用范围选用较长名称</h4> <blockquote><p>名称的长度应与作用范围的广泛度相关。对于较小的作用范围，可以用很短的名称，而对于较大作用范围就该用较长的名称。</p></blockquote> <h4 id="n6-名称应该说明副作用"><a href="#n6-名称应该说明副作用" class="header-anchor">#</a> N6 名称应该说明副作用</h4> <blockquote><p>名称应该说明函数、变量或类的一切信息。不要用名称掩蔽副作用。不要用简单的动词来描述一个做了不止一个简单动作的函数。例如，请看以下来自 TestNG 的代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ObjectOutputStream</span> <span class="token function">getOos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m_oos <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m_oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>m_socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> m_oos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>该函数不只是获取了一个 oos，如果 oos 不存在，还会创建一个。所以，更好的名字大概是 <code>createOrReturnOos</code>。</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">12/17/2020, 7:11:50 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/books/csapp.html">
        CSAPP
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.e9492735.js" defer></script><script src="/assets/js/2.6b359cc1.js" defer></script><script src="/assets/js/11.d727faee.js" defer></script>
  </body>
</html>
